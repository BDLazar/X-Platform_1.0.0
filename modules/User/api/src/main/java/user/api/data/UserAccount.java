package user.api.data;

import org.codehaus.jackson.annotate.JsonSubTypes;
import org.codehaus.jackson.annotate.JsonTypeInfo;
import org.codehaus.jackson.node.ObjectNode;

import javax.persistence.*;
import java.util.*;

@Entity
@Table(name = "USER_ACCOUNT")
@Inheritance(strategy=InheritanceType.JOINED)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
        include = JsonTypeInfo.As.PROPERTY,
        property = "userAccountType")
@JsonSubTypes(
        {@JsonSubTypes.Type(value = BasicUserAccount.class, name = "BASIC"),
        @JsonSubTypes.Type(value = StandardUserAccount.class, name = "STANDARD") })
public abstract class UserAccount {

    //region Properties

    @Id
    @GeneratedValue
    private Long id;

    @Enumerated(EnumType.STRING)
    private UserAccountType userAccountType;

    private String email;

    private String password;

    @OneToMany(fetch = FetchType.LAZY, cascade={CascadeType.ALL}, orphanRemoval = true)
    @MapKey(name="id")
    private Map<Long, UserProfile> userProfiles;

    //Transient properties are not stored in the database (we use withUserProfiles to know if we loaded the user profiles map from database)
    @Transient
    private boolean withUserProfiles;

    //endregion

    //region Constructors

    public UserAccount() {

        this.userProfiles = new LinkedHashMap<Long,UserProfile>();
    }

    public UserAccount(UserAccountType userAccountType) {

        this.userAccountType = userAccountType;
        this.userProfiles = new HashMap<Long,UserProfile>();

    }
    //endregion

    //region Getters & Setters

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public UserAccountType getUserAccountType() {

        return userAccountType;
    }

    public void setUserAccountType(UserAccountType userAccountType) {
        this.userAccountType = userAccountType;
    }

    public Map<Long, UserProfile> getUserProfiles() {
        return userProfiles;
    }

    public void setUserProfiles(Map<Long, UserProfile> userProfiles) {
        this.userProfiles = userProfiles;
    }

    public boolean isWithUserProfiles() {
        return withUserProfiles;
    }

    public void setWithUserProfiles(boolean withUserProfiles) {
        this.withUserProfiles = withUserProfiles;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    //endregion

    //region Parsers
    public abstract ObjectNode toJson();
    //endregion

    //region Business Methods
    public boolean assignUserProfile(UserProfile userProfile){

        /*We should only be able to add a user profile that does not already have a valid id because it will be generated by JPA (avoids id clashes)
         *We must also ensure we know what type of user profile it is to treat it accordingly*/
        if((userProfile.getId() == null || userProfile.getId() < 0) && userProfile.getUserProfileType() != null && this.isWithUserProfiles())
        {
            this.userProfiles.put(userProfile.getId(),userProfile);
            return true;
        }

        return false;
    }

    public boolean unassignUserProfile(Long userProfileId){

        if(this.withUserProfiles)
        {
            int amountBeforeRemove = this.userProfiles.size();
            this.userProfiles.remove(userProfileId);
            int amountAfterRemove = this.userProfiles.size();

            if(amountBeforeRemove > amountAfterRemove)
            {
                return true;
            }

            return false;
        }

        return false;
    }

    public UserProfile getUserProfile(Long userProfileId){

        if(this.withUserProfiles)
        {
            this.userProfiles.get(userProfileId);
        }

        return null;
    }

    public int updateFrom(UserAccount userAccountUpdates){

        int updatesAmount = 0;

        String newEmail = userAccountUpdates.getEmail();
        String newPassword = userAccountUpdates.getPassword();

        if (newEmail != null) {this.email = newEmail; updatesAmount++;}
        if (newEmail != null) {this.password = newPassword; updatesAmount++;}

        //update user profiles if they were loaded (we don't remove or add new profiles here we only take the existing user profiles into consideration)
        if(this.withUserProfiles)
        {
            //update existing user profiles that belong to this user account
            for(UserProfile userProfile : userAccountUpdates.getUserProfiles().values())
            {
                //Check that the id is valid
                if(userProfile.getId() > 0)
                {
                    //try find the existing corresponding user profile id
                    UserProfile existingUserProfile = this.userProfiles.get(userProfile.getId());

                    //we found it now lets update it and add it to the updated map
                    if(existingUserProfile != null)
                    {
                        updatesAmount = updatesAmount + existingUserProfile.updateFrom(userProfile);
                    }
                }

            }

        }

        return updatesAmount;
    }

    //endregion
}
